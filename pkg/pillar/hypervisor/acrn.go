// Copyright (c) 2017-2020 Zededa, Inc.
// SPDX-License-Identifier: Apache-2.0

package hypervisor

import (
	"bufio"
	"fmt"
	"io/ioutil"
	"os"
	"strconv"
	"strings"

	zconfig "github.com/lf-edge/eve/api/go/config"
	"github.com/lf-edge/eve/pkg/pillar/types"
	"github.com/lf-edge/eve/pkg/pillar/wrap"
	uuid "github.com/satori/go.uuid"
	log "github.com/sirupsen/logrus"
)

const stubDriverPath = "/sys/bus/pci/drivers/pci-stub"

type acrnDomainMetric struct {
	domainID int
	memory   int
}

type acrnContext struct {
	domains map[string]acrnDomainMetric
}

func newAcrn() Hypervisor {
	return acrnContext{}
}

func (ctx acrnContext) Name() string {
	return "acrn"
}

type acrnPCIAddress struct {
	bus, dev, fun int
}

func allocPCIAddress(a *[]acrnPCIAddress) string {
	for i := 2; i < 32; i++ {
		found := false

		for _, addr := range *a {
			if addr.dev == i {
				found = true
			}
		}

		if found == false {
			newaddr := acrnPCIAddress{0, i, 0}
			*a = append(*a, newaddr)
			return fmt.Sprintf("%d:%d:%d",
				newaddr.bus, newaddr.dev, newaddr.fun)
		}
	}
	return ""
}

func (ctx acrnContext) CreateDomConfig(domainName string, config types.DomainConfig, diskStatusList []types.DiskStatus,
	aa *types.AssignableAdapters, file *os.File) error {

	if config.VirtualizationMode != types.HVM {
		return logError("Internal error: Unsupported virtualizationMode %d",
			config.VirtualizationMode)
	}

	file.WriteString("# This file is automatically generated by domainmgr\n")

	// ACPI
	file.WriteString(fmt.Sprintf("-A\n"))

	// CPU
	if config.CPUs != "" {
		file.WriteString(fmt.Sprintf("--cpu_affinity %s\n", config.CPUs))
	}

	// Memory
	// Go from kbytes to mbytes
	kbyte2mbyte := func(kbyte int) int {
		return (kbyte + 1023) / 1024
	}
	file.WriteString(fmt.Sprintf("-m %d\n", kbyte2mbyte(config.Memory)))

	// UUID
	if config.UUIDandVersion.UUID != uuid.Nil {
		file.WriteString(fmt.Sprintf("-U %s\n",
			config.UUIDandVersion.UUID))
	}

	// PCI hostbridge
	file.WriteString(fmt.Sprintf("-s 0:0,hostbridge\n"))

	var pciAddrs []acrnPCIAddress

	for _, ds := range diskStatusList {
		if ds.Format != zconfig.Format_RAW {
			return logError("Internal error: Unsupported disk format %d",
				ds.Format)
		}

		access := ""
		if ds.ReadOnly {
			access = ",ro"
		}

		pciAddr := allocPCIAddress(&pciAddrs)
		if pciAddr == "" {
			return logError("Internal error: PCI addr alloc failed")
		}

		file.WriteString(fmt.Sprintf("-s %s,%s,%s%s\n",
			pciAddr, ds.Devtype, ds.FileLocation, access))
	}

	for _, net := range config.VifList {
		pciAddr := allocPCIAddress(&pciAddrs)
		if pciAddr == "" {
			return logError("Internal error: PCI addr alloc failed")
		}

		file.WriteString(fmt.Sprintf("[vif]%s|%s|%s\n",
			pciAddr, net.Bridge, net.Mac))
	}

	// Gather all PCI assignments and serials
	var pciAssignments []typeAndPCI
	var serialAssignments []string

	for _, adapter := range config.IoAdapterList {
		log.Debugf("configToAcrnCfg processing adapter %d %s\n",
			adapter.Type, adapter.Name)

		list := aa.LookupIoBundleAny(adapter.Name)
		// We reserved it in handleCreate so nobody could have stolen it
		if len(list) == 0 {
			log.Fatalf("configToAcrncfg IoBundle disappeared %d %s for %s\n",
				adapter.Type, adapter.Name, domainName)
		}

		for _, ib := range list {
			if ib == nil {
				continue
			}
			if ib.UsedByUUID != config.UUIDandVersion.UUID {
				log.Fatalf("configToAcrncfg IoBundle not ours %s: %d %s for %s\n",
					ib.UsedByUUID, adapter.Type, adapter.Name,
					domainName)
			}
			if ib.PciLong != "" {
				tap := typeAndPCI{pciLong: ib.PciLong, ioType: ib.Type}
				pciAssignments = addNoDuplicatePCI(pciAssignments, tap)
			}
			if ib.Serial != "" {
				log.Infof("Adding serial <%s>\n", ib.Serial)
				serialAssignments = addNoDuplicate(serialAssignments, ib.Serial)
			}
		}
	}

	if len(serialAssignments) != 0 {
		file.WriteString(fmt.Sprintf("-s 1:0,lpc\n"))

		for i, serial := range serialAssignments {
			if i > 1 {
				break
			}
			file.WriteString(fmt.Sprintf("-l com%d,%s\n",
				i+1, serial))
		}
	}

	if len(pciAssignments) != 0 {
		log.Infof("PCI assignments %v\n", pciAssignments)
		for _, pa := range pciAssignments {
			pciAddr := allocPCIAddress(&pciAddrs)
			if pciAddr == "" {
				return logError("Internal error: PCI addr alloc failed")
			}

			r := strings.NewReplacer(":", "/", ".", "/")
			short := types.PCILongToShort(pa.pciLong)
			file.WriteString(fmt.Sprintf("-s %s,passthru,%s\n",
				pciAddr, r.Replace(short)))
		}
	}

	// Bootloader
	if config.BootLoader != "" {
		file.WriteString(fmt.Sprintf("--ovmf %s\n",
			config.BootLoader))
	} else {
		file.WriteString(fmt.Sprintf("--ovmf %s\n",
			"/usr/share/acrn/bios/OVMF.fd"))
	}

	// VM name
	file.WriteString(fmt.Sprintf("[name]%s\n", domainName))
	metric := acrnDomainMetric{memory: config.Memory}
	ctx.domains[domainName] = metric
	return nil
}

func (ctx acrnContext) Create(domainName string, acrnCfgFilename string, config *types.DomainConfig) (int, error) {
	log.Infof("acrn create %s %s\n", domainName, acrnCfgFilename)

	file, err := os.Open(acrnCfgFilename)
	if err != nil {
		log.Errorf("cannot open %s: %s", acrnCfgFilename, err)
		return 0, fmt.Errorf("cannot open %s: %s\n",
			acrnCfgFilename, err)
	}
	defer file.Close()

	var args []string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		var s1, s2, s3 string
		arg := scanner.Text()

		n, e := fmt.Sscanf(arg, "-%s", &s1)
		if n == 1 && e == nil {
			args = append(args, arg)
			continue
		}

		n, e = fmt.Sscanf(arg, "#%s", &s1)
		if n == 1 && e == nil {
			continue
		}

		n, e = fmt.Sscanf(arg, "[vif]%s|%s|%s", &s1, &s2, &s3)
		if n == 3 && e == nil {
			args = append(args, fmt.Sprintf("-s %s,virtio-net,%s,mac=%s",
				s1, "tap", s3))
			continue
		}

		n, e = fmt.Sscanf(arg, "[name]%s", &s1)
		if n == 1 && e == nil {
			args = append(args, s1)
			continue
		}

		log.Errorln("unknown config: ", arg)
		return 0, fmt.Errorf("unknown config: %s\n", arg)
	}

	if err = scanner.Err(); err != nil {
		log.Errorln("invalid config: ", err)
		return 0, fmt.Errorf("invalid config: %v\n", err)
	}

	dm := "acrn-dm"
	cmd := wrap.Command(dm, args...)

	if err = cmd.Start(); err != nil {
		log.Errorln("acrn-dm failed: ", err)
		return 0, fmt.Errorf("acrn-dm failed: %v\n", err)
	}

	domainID := cmd.Process.Pid
	log.Infof("acrn create done\n")
	return domainID, nil
}

func (ctx acrnContext) Start(domainName string, domainID int) error {
	log.Infof("acrn start %s %d\n", domainName, domainID)

	stdoutStderr, err := wrap.Command("kill", "-s", "0",
		strconv.Itoa(domainID)).CombinedOutput()
	if err != nil {
		log.Errorln("acrn start failed: ", err)
		return fmt.Errorf("acrn start failed: %v\n", err)
	} else if string(stdoutStderr) != "" {
		log.Errorln("acrn start failed: ", string(stdoutStderr))
		return fmt.Errorf("acrn start failed: %s\n", string(stdoutStderr))
	}

	metric, found := ctx.domains[domainName]
	if !found {
		log.Errorf("acrn start failed: %s not found", domainName)
		return fmt.Errorf("acrn start failed: %s not found\n", domainName)
	}
	metric.domainID = domainID
	ctx.domains[domainName] = metric
	log.Infof("acrn start done\n")
	return nil
}

func (ctx acrnContext) Stop(domainName string, domainID int, force bool) error {
	log.Infof("acrn stop %s %d\n", domainName, domainID)
	cmd := "acrnctl"
	args := []string{
		"stop",
		"-f",
		domainName,
	}

	stdoutStderr, err := wrap.Command(cmd, args...).CombinedOutput()
	if err != nil {
		log.Errorln("acrn stop failed: ", err)
		log.Errorln("acrn stop output: ", string(stdoutStderr))
		return fmt.Errorf("acrn stop failed: %s\n",
			string(stdoutStderr))
	}

	delete(ctx.domains, domainName)
	log.Infof("acrn stop done\n")
	return nil
}

func (ctx acrnContext) Delete(domainName string, domainID int) error {
	log.Infof("acrn delete %s %d\n", domainName, domainID)
	log.Infof("acrn delete done\n")
	return nil
}

func (ctx acrnContext) Info(domainName string, domainID int) error {
	log.Infof("acrn info %s %d\n", domainName, domainID)
	log.Infof("acrn info done\n")
	return nil
}

func (ctx acrnContext) LookupByName(domainName string, domainID int) (int, error) {
	log.Infof("acrn lookup %s %d\n", domainName, domainID)
	if metric, found := ctx.domains[domainName]; !found || metric.domainID != domainID {
		return metric.domainID,
			logError("couldn't find domain %s or new id %d != old one %d",
				domainName, metric.domainID, domainID)
	}
	log.Infof("acrn lookup done\n")
	return domainID, nil
}

func (ctx acrnContext) Tune(domainName string, domainID int, vifCount int) error {
	return nil
}

func (ctx acrnContext) PCIReserve(long string) error {
	log.Infof("PCIReserve long addr is %s", long)

	overrideFile := sysfsPciDevices + long + "/driver_override"
	driverPath := sysfsPciDevices + long + "/driver"
	unbindFile := driverPath + "/unbind"

	// Check if already bound to pci-stub
	driverPathInfo, driverPathErr := os.Stat(driverPath)
	stubDriverPathInfo, stubDriverPathErr := os.Stat(stubDriverPath)
	if driverPathErr == nil && stubDriverPathErr == nil &&
		os.SameFile(driverPathInfo, stubDriverPathInfo) {
		log.Infof("Driver for %s is already bound to pci-stub, skipping unbind", long)
		return nil
	} else if stubDriverPathErr != nil && os.IsNotExist(stubDriverPathErr) {
		stdoutStderr, err := wrap.Command("modprobe", "pci_stub").CombinedOutput()
		if err != nil {
			log.Errorln("acrn pcireserve failed: ", err)
			log.Errorln("acrn pcireserve output: ", string(stdoutStderr))
			return fmt.Errorf("acrn pcireserve failed: %s\n",
				string(stdoutStderr))
		}
	}

	// Map pci-stub as the driver_override for the device
	if err := ioutil.WriteFile(overrideFile, []byte("pci-stub"), 0644); err != nil {
		log.Fatalf("driver_override failure for PCI device %s: %v",
			long, err)
	}

	// Unbind the current driver, whatever it is, if there is one
	if _, err := os.Stat(unbindFile); err == nil {
		if err := ioutil.WriteFile(unbindFile, []byte(long), 0644); err != nil {
			log.Fatalf("unbind failure for PCI device %s: %v",
				long, err)
		}
	}

	if err := ioutil.WriteFile(sysfsPciDriversProbe, []byte(long), 0644); err != nil {
		log.Fatalf("drivers_probe failure for PCI device %s: %v",
			long, err)
	}

	return nil
}

func (ctx acrnContext) PCIRelease(long string) error {
	log.Errorf("PCIRelease long addr is %s", long)

	overrideFile := sysfsPciDevices + long + "/driver_override"
	unbindFile := sysfsPciDevices + long + "/driver/unbind"

	// Write Empty string, to clear driver_override for the device
	if err := ioutil.WriteFile(overrideFile, []byte(""), 0644); err != nil {
		log.Fatalf("driver_override failure for PCI device %s: %v",
			long, err)
	}

	// Unbind pci-stub, if unbind file is present
	if _, err := os.Stat(unbindFile); err == nil {
		if err := ioutil.WriteFile(unbindFile, []byte(long), 0644); err != nil {
			log.Fatalf("unbind failure for PCI device %s: %v",
				long, err)
		}
	}

	// Write PCI DDDD:BB:DD.FF to /sys/bus/pci/drivers_probe,
	// as a best-effort to bring back original driver
	if err := ioutil.WriteFile(sysfsPciDriversProbe, []byte(long), 0644); err != nil {
		log.Fatalf("drivers_probe failure for PCI device %s: %v",
			long, err)
	}

	return nil
}

//Returns true in case of undetermined/unknown health state ( e.g., due to a pending state transition).
//Caller must not assume that domain is unhealthy, since it might be transitioning between healthy states.
func (ctx acrnContext) IsDomainPotentiallyShuttingDown(domainName string) bool {
	// TODO
	return false
}

func (ctx acrnContext) IsDeviceModelAlive(domid int) bool {
	_, err := os.Stat(fmt.Sprintf("/proc/%d", domid))
	return err == nil
}

func (ctx acrnContext) GetHostCPUMem() (types.HostMemory, error) {
	return selfDomCPUMem()
}

func (ctx acrnContext) GetDomsCPUMem() (map[string]types.DomainMetric, error) {
	res := map[string]types.DomainMetric{}

	for dom, metric := range ctx.domains {
		res[dom] = types.DomainMetric{
			CPUTotal:          1, // TODO platform_info
			UsedMemory:        uint32(metric.memory),
			AvailableMemory:   0,
			UsedMemoryPercent: float64(1),
		}
	}
	return res, nil
}
